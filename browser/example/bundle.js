/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./browser/src/BasicParser.ts":
/*!************************************!*\
  !*** ./browser/src/BasicParser.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BasicParser = void 0;\nclass BasicParser {\n    constructor(input) {\n        this.input = input;\n        this.index = 0;\n    }\n    char() {\n        return this.input[this.index];\n    }\n    next(len) {\n        len = len || 1;\n        this.index += len;\n    }\n    eat(char) {\n        if (typeof char === 'string') {\n            this.assert(char);\n        }\n        const text = char ? char : this.char();\n        this.next(text ? text.length : 1);\n        return text;\n    }\n    assert(char) {\n        if (!this.input.substring(this.index).startsWith(char)) {\n            throw new Error(`unexpected char ${char}`);\n        }\n    }\n    consumeWhitespace() {\n        const whitespace = /[\\t|\\r|\\n| ]/;\n        const startIndex = this.index;\n        while (whitespace.test(this.char())) {\n            this.eat();\n        }\n        return this.input.substring(startIndex, this.index);\n    }\n    startsWith(input) {\n        return this.input.substring(this.index).indexOf(input) === 0;\n    }\n    end() {\n        return this.index >= this.input.length;\n    }\n    consumeCharsWhile(predicate) {\n        let text = '';\n        while (predicate(this.char()) && !this.end()) {\n            text += this.eat();\n        }\n        return text;\n    }\n    isValidIdentifierStart() {\n        const char = this.char();\n        return (typeof char === 'string' && char.length === 1 && /[a-zA-Z0-9]/.test(char));\n    }\n    parseIdentifier() {\n        return this.consumeCharsWhile((char) => /[a-zA-Z0-9]/.test(char));\n    }\n    isDigit() {\n        const char = this.char();\n        return typeof char === 'string' && char.length === 1 && /[0-9]/.test(char);\n    }\n    isHexDigit() {\n        const char = this.char();\n        return (typeof char === 'string' && char.length === 1 && /[0-9a-fA-F]/.test(char));\n    }\n}\nexports.BasicParser = BasicParser;\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/BasicParser.ts?");

/***/ }),

/***/ "./browser/src/css/MatchedRule.ts":
/*!****************************************!*\
  !*** ./browser/src/css/MatchedRule.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MatchedRule = void 0;\nclass MatchedRule {\n    constructor(specificity, rule) {\n        this.specificity = specificity;\n        this.rule = rule;\n    }\n}\nexports.MatchedRule = MatchedRule;\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/css/MatchedRule.ts?");

/***/ }),

/***/ "./browser/src/css/Rule.ts":
/*!*********************************!*\
  !*** ./browser/src/css/Rule.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Rule = void 0;\nclass Rule {\n    constructor(selectors, declarations) {\n        this.selectors = selectors;\n        this.declarations = declarations;\n    }\n}\nexports.Rule = Rule;\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/css/Rule.ts?");

/***/ }),

/***/ "./browser/src/css/Selector.ts":
/*!*************************************!*\
  !*** ./browser/src/css/Selector.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Selector = void 0;\nclass Selector {\n    constructor(classes, tagName, id) {\n        this.classes = classes;\n        this.tagName = tagName;\n        this.id = id;\n    }\n}\nexports.Selector = Selector;\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/css/Selector.ts?");

/***/ }),

/***/ "./browser/src/css/Specificity.ts":
/*!****************************************!*\
  !*** ./browser/src/css/Specificity.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Specificity = void 0;\nclass Specificity {\n    constructor(options) {\n        this.options = options;\n    }\n    compare(other) {\n        const properties = ['id', 'tag', 'classes'];\n        for (let prop of properties) {\n            if (this.options[prop] < other.options[prop]) {\n                return -1;\n            }\n            if (this.options[prop] > other.options[prop]) {\n                return -1;\n            }\n        }\n        return 0;\n    }\n    static from(selector) {\n        return new Specificity({\n            id: selector.id ? 1 : 0,\n            tag: selector.tagName ? 1 : 0,\n            classes: selector.classes.length,\n        });\n    }\n}\nexports.Specificity = Specificity;\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/css/Specificity.ts?");

/***/ }),

/***/ "./browser/src/css/index.ts":
/*!**********************************!*\
  !*** ./browser/src/css/index.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseCSS = exports.CSSParser = exports.DeclarationValueColor = exports.Unit = exports.DeclarationValueLength = exports.DeclarationValueKeyword = exports.DeclarationValue = exports.DeclarationValueType = exports.Declaration = exports.StyleSheet = void 0;\nconst BasicParser_1 = __webpack_require__(/*! ../BasicParser */ \"./browser/src/BasicParser.ts\");\nconst Rule_1 = __webpack_require__(/*! ./Rule */ \"./browser/src/css/Rule.ts\");\nconst Selector_1 = __webpack_require__(/*! ./Selector */ \"./browser/src/css/Selector.ts\");\nclass StyleSheet {\n    constructor(rules) {\n        this.rules = rules;\n    }\n}\nexports.StyleSheet = StyleSheet;\nclass Declaration {\n    constructor(name, value) {\n        this.name = name;\n        this.value = value;\n    }\n}\nexports.Declaration = Declaration;\nvar DeclarationValueType;\n(function (DeclarationValueType) {\n    DeclarationValueType[DeclarationValueType[\"Keyword\"] = 0] = \"Keyword\";\n    DeclarationValueType[DeclarationValueType[\"Length\"] = 1] = \"Length\";\n    DeclarationValueType[DeclarationValueType[\"Color\"] = 2] = \"Color\";\n})(DeclarationValueType = exports.DeclarationValueType || (exports.DeclarationValueType = {}));\nclass DeclarationValue {\n    constructor(type) {\n        this.type = type;\n    }\n    toPix() {\n        if (this instanceof DeclarationValueLength) {\n            return this.value;\n        }\n        if (this instanceof DeclarationValueKeyword && this.value === 'auto') {\n            return 0;\n        }\n        throw new Error(`unexpected value ${this.type}`);\n    }\n}\nexports.DeclarationValue = DeclarationValue;\nclass DeclarationValueKeyword extends DeclarationValue {\n    constructor(value) {\n        super(DeclarationValueType.Keyword);\n        this.value = value;\n    }\n    static of(name) {\n        let value = DeclarationValueKeyword.cached.get(name);\n        if (value) {\n            return value;\n        }\n        value = new DeclarationValueKeyword(name);\n        DeclarationValueKeyword.cached.set(name, value);\n        return value;\n    }\n}\nexports.DeclarationValueKeyword = DeclarationValueKeyword;\nDeclarationValueKeyword.cached = new Map();\nclass DeclarationValueLength extends DeclarationValue {\n    constructor(value, unit) {\n        super(DeclarationValueType.Length);\n        this.value = value;\n        this.unit = unit;\n    }\n}\nexports.DeclarationValueLength = DeclarationValueLength;\nvar Unit;\n(function (Unit) {\n    Unit[Unit[\"Px\"] = 0] = \"Px\";\n})(Unit = exports.Unit || (exports.Unit = {}));\nclass DeclarationValueColor extends DeclarationValue {\n    constructor(value) {\n        super(DeclarationValueType.Color);\n        this.value = value;\n    }\n}\nexports.DeclarationValueColor = DeclarationValueColor;\nclass CSSParser extends BasicParser_1.BasicParser {\n    parseCSS() {\n        const rules = [];\n        for (;;) {\n            this.consumeWhitespace();\n            if (this.end()) {\n                break;\n            }\n            rules.push(this.parseRule());\n        }\n        return new StyleSheet(rules);\n    }\n    parseRule() {\n        const selectors = this.parseSelectors();\n        const declarations = this.parseDeclarations();\n        return new Rule_1.Rule(selectors, declarations);\n    }\n    parseSelectors() {\n        const selectors = [];\n        for (;;) {\n            selectors.push(this.parseSelector());\n            this.consumeWhitespace();\n            if (this.char() === ',') {\n                this.eat();\n                this.consumeWhitespace();\n            }\n            else if (this.char() === '{') {\n                break;\n            }\n            else {\n                throw new Error(`unexpected token ${this.char()}, expect ',' or '{' after selector `);\n            }\n        }\n        return selectors;\n    }\n    parseSelector() {\n        // tag#id.class1.class2\n        const simpleSelector = new Selector_1.Selector([]);\n        for (;;) {\n            if (this.isValidIdentifierStart()) {\n                simpleSelector.tagName = this.parseIdentifier();\n            }\n            else if (this.char() === '#') {\n                this.eat();\n                simpleSelector.id = this.parseIdentifier();\n            }\n            else if (this.char() === '.') {\n                // no duplicate class detection\n                this.eat();\n                simpleSelector.classes.push(this.parseIdentifier());\n            }\n            else if (this.char() === '*') {\n                // universal\n            }\n            else {\n                break;\n            }\n        }\n        return simpleSelector;\n    }\n    parseDeclarations() {\n        const declarations = [];\n        this.eat('{');\n        for (;;) {\n            this.consumeWhitespace();\n            if (this.char() === '}') {\n                break;\n            }\n            declarations.push(this.parseDeclaration());\n        }\n        this.eat('}');\n        return declarations;\n    }\n    // font-size\n    parseIdentifier() {\n        return this.consumeCharsWhile((char) => /[a-zA-Z0-9\\-]/.test(char));\n    }\n    parseDeclaration() {\n        const name = this.parseIdentifier();\n        this.eat(':');\n        this.consumeWhitespace();\n        const value = this.parseDeclarationValue();\n        this.consumeWhitespace();\n        this.eat(';');\n        return new Declaration(name, value);\n    }\n    parseDeclarationValue() {\n        if (this.isDigit()) {\n            const length = this.parseFloat();\n            const unit = this.eat('px');\n            return new DeclarationValueLength(length, Unit.Px);\n        }\n        if (this.char() === '#') {\n            return this.parseColor();\n        }\n        const name = this.parseIdentifier();\n        if (name === undefined) {\n            throw new Error('expect identifer');\n        }\n        return DeclarationValueKeyword.of(name);\n    }\n    parseColor() {\n        this.eat('#');\n        return new DeclarationValueColor({\n            r: this.parseHexPair(),\n            g: this.parseHexPair(),\n            b: this.parseHexPair(),\n            a: 255,\n        });\n    }\n    parseHexPair() {\n        if (!this.isHexDigit()) {\n            throw new Error(`expect hex digit in color, get ${this.char()}`);\n        }\n        const high = this.eat();\n        if (!this.isHexDigit()) {\n            throw new Error(`expect hex digit in color, get ${this.char()}`);\n        }\n        const low = this.eat();\n        return Number.parseInt(`${high}${low}`, 16);\n    }\n    parseFloat() {\n        const text = this.consumeCharsWhile((char) => /[0-9\\.]/.test(char));\n        return Number.parseFloat(text);\n    }\n}\nexports.CSSParser = CSSParser;\n/**\n * parse multiple rules with multiple selectors and multiple declarations\n */\nfunction parseCSS(input) {\n    const parser = new CSSParser(input);\n    return parser.parseCSS();\n}\nexports.parseCSS = parseCSS;\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/css/index.ts?");

/***/ }),

/***/ "./browser/src/html/HTMLParser.ts":
/*!****************************************!*\
  !*** ./browser/src/html/HTMLParser.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseHTML = void 0;\nconst Node_1 = __webpack_require__(/*! ./Node */ \"./browser/src/html/Node.ts\");\nconst BasicParser_1 = __webpack_require__(/*! ../BasicParser */ \"./browser/src/BasicParser.ts\");\nfunction isHTMLElement(node) {\n    return node.type === Node_1.NodeType.Element && node.name === 'html';\n}\nclass HTMLParser extends BasicParser_1.BasicParser {\n    parseHTML() {\n        const nodes = this.parseNodes();\n        if (nodes.length === 1) {\n            const node = nodes[0];\n            if (isHTMLElement(node)) {\n                return node;\n            }\n            throw new Error(`single root node must be html, get ${nodes[0]}`);\n        }\n        return new Node_1.ElementNode('html', {}, nodes);\n    }\n    parseNodes() {\n        const nodes = [];\n        for (;;) {\n            if (this.startsWith('</') || this.end()) {\n                break;\n            }\n            nodes.push(this.parseNode());\n        }\n        return nodes;\n    }\n    parseNode() {\n        if (this.startsWith('<')) {\n            return this.parseElement();\n        }\n        return this.parseTextNode();\n    }\n    parseElement() {\n        this.eat('<');\n        const tagName = this.parseTagName();\n        const attributes = this.parseTagAttributes();\n        this.eat('>');\n        const children = this.parseNodes();\n        this.eat('<');\n        this.eat('/');\n        this.eat(tagName);\n        this.eat('>');\n        return new Node_1.ElementNode(tagName, attributes, children);\n    }\n    parseTagName() {\n        return this.parseIdentifier();\n    }\n    parseTagAttributes() {\n        const attributes = {};\n        for (;;) {\n            if (this.char() === '>') {\n                break;\n            }\n            const { name, value } = this.parseTagAttribute();\n            attributes[name] = value;\n        }\n        return attributes;\n    }\n    parseTagAttribute() {\n        this.consumeWhitespace();\n        const name = this.parseTagName();\n        this.eat('=');\n        const value = this.parseTagValue();\n        return {\n            name,\n            value,\n        };\n    }\n    parseTagValue() {\n        const quote = this.char();\n        if (quote !== '\"' && quote !== \"'\") {\n            throw new Error('expect quote');\n        }\n        this.next();\n        let value = '';\n        for (;;) {\n            if (this.char() === quote) {\n                this.next();\n                break;\n            }\n            value += this.char();\n            this.next();\n        }\n        return value;\n    }\n    parseTextNode() {\n        const text = this.consumeCharsWhile((char) => char !== '<');\n        return new Node_1.TextNode(text);\n    }\n}\nexports.default = HTMLParser;\nfunction parseHTML(input) {\n    const parser = new HTMLParser(input);\n    return parser.parseHTML();\n}\nexports.parseHTML = parseHTML;\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/html/HTMLParser.ts?");

/***/ }),

/***/ "./browser/src/html/Node.ts":
/*!**********************************!*\
  !*** ./browser/src/html/Node.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ElementNode = exports.TextNode = exports.Node = exports.NodeType = void 0;\nvar NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"Element\"] = 0] = \"Element\";\n    NodeType[NodeType[\"Text\"] = 1] = \"Text\";\n})(NodeType = exports.NodeType || (exports.NodeType = {}));\nclass Node {\n    constructor(type) {\n        this.type = type;\n    }\n}\nexports.Node = Node;\nclass TextNode extends Node {\n    constructor(value) {\n        super(NodeType.Text);\n        this.value = value;\n    }\n}\nexports.TextNode = TextNode;\nclass ElementNode extends Node {\n    constructor(name, attributes, children) {\n        super(NodeType.Element);\n        this.name = name;\n        this.attributes = attributes;\n        this.children = children;\n    }\n}\nexports.ElementNode = ElementNode;\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/html/Node.ts?");

/***/ }),

/***/ "./browser/src/html/index.ts":
/*!***********************************!*\
  !*** ./browser/src/html/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseHTML = void 0;\nvar HTMLParser_1 = __webpack_require__(/*! ./HTMLParser */ \"./browser/src/html/HTMLParser.ts\");\nObject.defineProperty(exports, \"parseHTML\", ({ enumerable: true, get: function () { return HTMLParser_1.parseHTML; } }));\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/html/index.ts?");

/***/ }),

/***/ "./browser/src/layout/Dimensions.ts":
/*!******************************************!*\
  !*** ./browser/src/layout/Dimensions.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Dimensions = void 0;\nconst EdgeSize_1 = __webpack_require__(/*! ./EdgeSize */ \"./browser/src/layout/EdgeSize.ts\");\nconst Rect_1 = __webpack_require__(/*! ./Rect */ \"./browser/src/layout/Rect.ts\");\nclass Dimensions {\n    constructor(content, padding, border, margin) {\n        this.content = content;\n        this.padding = padding;\n        this.border = border;\n        this.margin = margin;\n    }\n    static default() {\n        return new Dimensions(Rect_1.Rect.default(), EdgeSize_1.EdgeSize.default(), EdgeSize_1.EdgeSize.default(), EdgeSize_1.EdgeSize.default());\n    }\n    contentBox() {\n        return this.content;\n    }\n    paddingBox() {\n        return this.contentBox().expand(this.padding);\n    }\n    borderBox() {\n        return this.paddingBox().expand(this.border);\n    }\n    marginBox() {\n        return this.borderBox().expand(this.margin);\n    }\n}\nexports.Dimensions = Dimensions;\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/layout/Dimensions.ts?");

/***/ }),

/***/ "./browser/src/layout/EdgeSize.ts":
/*!****************************************!*\
  !*** ./browser/src/layout/EdgeSize.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EdgeSize = void 0;\nclass EdgeSize {\n    constructor(left, top, right, bottom) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n    static default() {\n        return new EdgeSize(0, 0, 0, 0);\n    }\n}\nexports.EdgeSize = EdgeSize;\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/layout/EdgeSize.ts?");

/***/ }),

/***/ "./browser/src/layout/Rect.ts":
/*!************************************!*\
  !*** ./browser/src/layout/Rect.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Rect = void 0;\nclass Rect {\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    static default() {\n        return new Rect(0, 0, 0, 0);\n    }\n    expand(edgeSize) {\n        return new Rect(this.x - edgeSize.left, this.y - edgeSize.top, this.width + edgeSize.left + edgeSize.right, this.height + edgeSize.top + edgeSize.bottom);\n    }\n}\nexports.Rect = Rect;\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/layout/Rect.ts?");

/***/ }),

/***/ "./browser/src/layout/index.ts":
/*!*************************************!*\
  !*** ./browser/src/layout/index.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.buildLayoutTree = exports.getDisplayValue = exports.getLayoutBoxType = exports.LayoutBox = exports.LayoutBoxType = void 0;\nconst css_1 = __webpack_require__(/*! ../css */ \"./browser/src/css/index.ts\");\nconst Dimensions_1 = __webpack_require__(/*! ./Dimensions */ \"./browser/src/layout/Dimensions.ts\");\nvar LayoutBoxType;\n(function (LayoutBoxType) {\n    LayoutBoxType[LayoutBoxType[\"Block\"] = 0] = \"Block\";\n    LayoutBoxType[LayoutBoxType[\"Inline\"] = 1] = \"Inline\";\n    LayoutBoxType[LayoutBoxType[\"Anonymous\"] = 2] = \"Anonymous\";\n})(LayoutBoxType = exports.LayoutBoxType || (exports.LayoutBoxType = {}));\nclass LayoutBox {\n    constructor(boxType, node) {\n        this.boxType = boxType;\n        this.node = node;\n        this.dimensions = Dimensions_1.Dimensions.default();\n        this.children = [];\n    }\n    getInlineContainer() {\n        switch (this.boxType) {\n            case LayoutBoxType.Inline:\n            case LayoutBoxType.Anonymous:\n                return this;\n            case LayoutBoxType.Block:\n                const lastChild = this.children[this.children.length - 1];\n                if (lastChild && lastChild.boxType === LayoutBoxType.Anonymous) {\n                    return lastChild;\n                }\n                else {\n                    const anonymousBox = new LayoutBox(LayoutBoxType.Anonymous);\n                    this.children.push(anonymousBox);\n                    return anonymousBox;\n                }\n        }\n    }\n    layout(containingBlock) {\n        switch (this.boxType) {\n            case LayoutBoxType.Block:\n                this.layoutBlock(containingBlock);\n            case LayoutBoxType.Inline:\n            case LayoutBoxType.Anonymous:\n                break;\n        }\n    }\n    layoutBlock(containingBlock) {\n        this.calculateBlockWidth(containingBlock);\n        this.calculateBlockPosition(containingBlock);\n        this.layoutBlockChildren();\n        this.calculateBlockHeight(containingBlock);\n    }\n    calculateBlockWidth(containingBlock) {\n        const node = this.getStyleNode();\n        const auto = css_1.DeclarationValueKeyword.of('auto');\n        let width = node.value('width') || auto;\n        const zero = new css_1.DeclarationValueLength(0, css_1.Unit.Px);\n        let marginLeft = node.lookup('margin-left', 'margin', zero);\n        const borderLeft = node.lookup('border-left-width', 'border-width', zero);\n        const paddingLeft = node.lookup('padding-left', 'padding', zero);\n        let marginRight = node.lookup('margin-right', 'margin', zero);\n        const borderRight = node.lookup('border-right-width', 'border-width', zero);\n        const paddingRight = node.lookup('padding-right', 'padding', zero);\n        const totalWidth = [\n            marginLeft,\n            borderLeft,\n            paddingLeft,\n            width,\n            paddingRight,\n            borderRight,\n            marginRight,\n        ].reduce((acc, value) => {\n            return acc + value.toPix();\n        }, 0);\n        const underflow = containingBlock.content.width - totalWidth;\n        // 把auto值转换为固定长度值\n        // overflow\n        if (underflow < 0) {\n            if (marginLeft === auto) {\n                marginLeft = new css_1.DeclarationValueLength(0, css_1.Unit.Px);\n            }\n            if (marginRight === auto) {\n                marginRight = new css_1.DeclarationValueLength(0, css_1.Unit.Px);\n            }\n            if (width === auto) {\n                width = new css_1.DeclarationValueLength(0, css_1.Unit.Px);\n            }\n            else {\n                marginRight = new css_1.DeclarationValueLength(marginRight.toPix() + underflow, css_1.Unit.Px);\n            }\n        }\n        else {\n            // underflow 的8种情况\n            if (width !== auto) {\n                if (marginLeft === auto && marginRight === auto) {\n                    marginLeft = marginRight = new css_1.DeclarationValueLength(0.5 * underflow, css_1.Unit.Px);\n                }\n                else if (marginLeft === auto && marginRight !== auto) {\n                    marginLeft = new css_1.DeclarationValueLength(underflow, css_1.Unit.Px);\n                }\n                else if (marginLeft !== auto && marginRight === auto) {\n                    marginRight = new css_1.DeclarationValueLength(underflow, css_1.Unit.Px);\n                }\n                else if (marginLeft !== auto && marginRight !== auto) {\n                    marginRight = new css_1.DeclarationValueLength(marginRight.toPix() + underflow, css_1.Unit.Px);\n                }\n            }\n            else {\n                width = new css_1.DeclarationValueLength(underflow, css_1.Unit.Px);\n                if (marginLeft === auto) {\n                    marginLeft = new css_1.DeclarationValueLength(0, css_1.Unit.Px);\n                }\n                if (marginRight === auto) {\n                    marginRight = new css_1.DeclarationValueLength(0, css_1.Unit.Px);\n                }\n            }\n        }\n        this.dimensions.content.width = width.toPix();\n        this.dimensions.padding.left = paddingLeft.toPix();\n        this.dimensions.padding.right = paddingRight.toPix();\n        this.dimensions.border.left = borderLeft.toPix();\n        this.dimensions.border.right = borderRight.toPix();\n        this.dimensions.margin.left = marginLeft.toPix();\n        this.dimensions.margin.right = marginRight.toPix();\n    }\n    getStyleNode() {\n        if (this.boxType === LayoutBoxType.Anonymous || !this.node) {\n            throw new Error('anonymous box has no style node');\n        }\n        return this.node;\n    }\n    // 竖直方向\n    calculateBlockPosition(containingBlock) {\n        const node = this.getStyleNode();\n        const zero = new css_1.DeclarationValueLength(0, css_1.Unit.Px);\n        this.dimensions.padding.top = node\n            .lookup('padding-top', 'padding', zero)\n            .toPix();\n        this.dimensions.padding.bottom = node\n            .lookup('padding-bottom', 'padding', zero)\n            .toPix();\n        this.dimensions.border.top = node\n            .lookup('border-top', 'border', zero)\n            .toPix();\n        this.dimensions.border.bottom = node\n            .lookup('border-bottom', 'border', zero)\n            .toPix();\n        this.dimensions.margin.top = node\n            .lookup('margin-top', 'margin', zero)\n            .toPix();\n        this.dimensions.margin.bottom = node\n            .lookup('margin-bottom', 'margin', zero)\n            .toPix();\n        this.dimensions.content.x =\n            containingBlock.content.x +\n                this.dimensions.margin.left +\n                this.dimensions.padding.left +\n                this.dimensions.border.left;\n        // Block Layout竖直方向排列\n        this.dimensions.content.y =\n            // box layout 的竖直方向排列\n            containingBlock.content.height +\n                containingBlock.content.y +\n                this.dimensions.margin.top +\n                this.dimensions.padding.top +\n                this.dimensions.border.top;\n    }\n    layoutBlockChildren() {\n        this.children.forEach((child) => {\n            child.layout(this.dimensions);\n            // 每个子盒子高度确定后，重新撑开父盒子，更新其高度\n            this.dimensions.content.height += child.dimensions.marginBox().height;\n        });\n    }\n    calculateBlockHeight(containingBlock) {\n        const node = this.getStyleNode();\n        const height = node.value('height');\n        if (height instanceof css_1.DeclarationValueLength) {\n            this.dimensions.content.height = height.value;\n        }\n    }\n}\nexports.LayoutBox = LayoutBox;\nfunction getLayoutBoxType(node) {\n    const display = node.specifiedValues['display'];\n    if (display instanceof css_1.DeclarationValueKeyword) {\n        if (display.value === 'block') {\n            return LayoutBoxType.Block;\n        }\n        else if (display.value === 'none') {\n            return LayoutBoxType.Inline;\n        }\n        else {\n            return LayoutBoxType.Block;\n        }\n    }\n    return LayoutBoxType.Block;\n}\nexports.getLayoutBoxType = getLayoutBoxType;\nfunction getDisplayValue(node) {\n    const display = node.specifiedValues['display'];\n    if (display instanceof css_1.DeclarationValueKeyword) {\n        if (display.value === 'block') {\n            return 'block';\n        }\n        else if (display.value === 'none') {\n            return 'none';\n        }\n        else {\n            return 'inline';\n        }\n    }\n    return 'inline';\n}\nexports.getDisplayValue = getDisplayValue;\nfunction buildLayoutTree(node) {\n    const display = getDisplayValue(node);\n    const root = new LayoutBox(LayoutBoxType.Block, node);\n    switch (display) {\n        case 'inline':\n            root.boxType = LayoutBoxType.Inline;\n            break;\n        case 'block':\n            root.boxType = LayoutBoxType.Block;\n            break;\n        case 'none':\n            throw new Error('display none at root node not allowed');\n    }\n    node.children.forEach((child) => {\n        const childDisplay = getDisplayValue(child);\n        switch (childDisplay) {\n            case 'block':\n                root.children.push(buildLayoutTree(child));\n                break;\n            case 'inline':\n                root.getInlineContainer().children.push(buildLayoutTree(child));\n            case 'none':\n                break;\n        }\n    });\n    return root;\n}\nexports.buildLayoutTree = buildLayoutTree;\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/layout/index.ts?");

/***/ }),

/***/ "./browser/src/painting/index.ts":
/*!***************************************!*\
  !*** ./browser/src/painting/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.drawLayoutBoxAsCanvasData = exports.getBoxColor = exports.renderBorders = exports.renderBackground = exports.renderLayoutBox = exports.buildDisplayList = void 0;\nconst layout_1 = __webpack_require__(/*! ../layout */ \"./browser/src/layout/index.ts\");\nconst Rect_1 = __webpack_require__(/*! ../layout/Rect */ \"./browser/src/layout/Rect.ts\");\nconst css_1 = __webpack_require__(/*! ../css */ \"./browser/src/css/index.ts\");\nclass DisplayCommand {\n}\nclass DisplayCommandSolidColor extends DisplayCommand {\n    constructor(color, rect) {\n        super();\n        this.color = color;\n        this.rect = rect;\n    }\n}\nfunction buildDisplayList(layoutBox) {\n    const displayList = [];\n    renderLayoutBox(displayList, layoutBox);\n    return displayList;\n}\nexports.buildDisplayList = buildDisplayList;\nfunction renderLayoutBox(list, layoutBox) {\n    renderBackground(list, layoutBox);\n    renderBorders(list, layoutBox);\n    layoutBox.children.forEach((child) => {\n        renderLayoutBox(list, child);\n    });\n}\nexports.renderLayoutBox = renderLayoutBox;\nfunction renderBackground(list, layoutBox) {\n    const backgroundColor = getBoxColor(layoutBox, 'background');\n    if (!backgroundColor) {\n        return;\n    }\n    list.push(new DisplayCommandSolidColor(backgroundColor, layoutBox.dimensions.borderBox()));\n}\nexports.renderBackground = renderBackground;\nfunction renderBorders(list, layoutBox) {\n    const borderColor = getBoxColor(layoutBox, 'border-color');\n    if (!borderColor) {\n        return;\n    }\n    const dimensions = layoutBox.dimensions;\n    const borderBox = layoutBox.dimensions.borderBox();\n    // left\n    list.push(new DisplayCommandSolidColor(borderColor, new Rect_1.Rect(borderBox.x, borderBox.y, dimensions.border.left, borderBox.height)));\n    // right\n    list.push(new DisplayCommandSolidColor(borderColor, new Rect_1.Rect(borderBox.x +\n        dimensions.border.left +\n        dimensions.padding.left +\n        dimensions.content.width, borderBox.y, dimensions.border.right, borderBox.height)));\n    // top border\n    list.push(new DisplayCommandSolidColor(borderColor, new Rect_1.Rect(borderBox.x, borderBox.y, dimensions.border.top, borderBox.width)));\n    // bottom color\n    list.push(new DisplayCommandSolidColor(borderColor, new Rect_1.Rect(borderBox.x, borderBox.y + borderBox.height - dimensions.border.bottom, borderBox.width, dimensions.border.bottom)));\n}\nexports.renderBorders = renderBorders;\nfunction getBoxColor(layoutBox, name) {\n    switch (layoutBox.boxType) {\n        case layout_1.LayoutBoxType.Block:\n        case layout_1.LayoutBoxType.Inline:\n            const styleNode = layoutBox.getStyleNode();\n            const value = styleNode.value(name);\n            if (value) {\n                if (value instanceof css_1.DeclarationValueColor) {\n                    return value.value;\n                }\n                else {\n                    throw new Error(`style ${name} value is not color, get ${value}|`);\n                }\n            }\n        case layout_1.LayoutBoxType.Anonymous:\n        default:\n            break;\n    }\n}\nexports.getBoxColor = getBoxColor;\nfunction drawLayoutBoxAsCanvasData(layoutBox, borderBox) {\n    // const borderBox = layoutBox.dimensions.borderBox()\n    const canvasData = {\n        data: new Uint8ClampedArray(4 * borderBox.width * borderBox.height),\n        width: borderBox.width,\n        height: borderBox.height,\n    };\n    const displayCommandList = buildDisplayList(layoutBox);\n    for (const command of displayCommandList) {\n        if (command instanceof DisplayCommandSolidColor) {\n            applyCommandToCanvasData(command, canvasData);\n        }\n    }\n    return canvasData;\n}\nexports.drawLayoutBoxAsCanvasData = drawLayoutBoxAsCanvasData;\nfunction applyCommandToCanvasData(command, canvasData) {\n    const { rect } = command;\n    const x0 = rect.x;\n    const x1 = rect.x + rect.width;\n    const y0 = rect.y;\n    const y1 = rect.y + rect.height;\n    for (let x = x0; x < x1; x++) {\n        for (let y = y0; y < y1; y++) {\n            canvasData.data[(x + rect.width * y) * 4] = command.color.r;\n            canvasData.data[(x + rect.width * y) * 4 + 1] = command.color.g;\n            canvasData.data[(x + rect.width * y) * 4 + 2] = command.color.b;\n            canvasData.data[(x + rect.width * y) * 4 + 3] = command.color.a;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/painting/index.ts?");

/***/ }),

/***/ "./browser/src/style/index.ts":
/*!************************************!*\
  !*** ./browser/src/style/index.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.doCreateStyleTree = exports.createStyleTree = exports.StyleNode = void 0;\nconst Node_1 = __webpack_require__(/*! ../html/Node */ \"./browser/src/html/Node.ts\");\nconst css_1 = __webpack_require__(/*! ../css */ \"./browser/src/css/index.ts\");\nconst html_1 = __webpack_require__(/*! ../html */ \"./browser/src/html/index.ts\");\nconst MatchedRule_1 = __webpack_require__(/*! ../css/MatchedRule */ \"./browser/src/css/MatchedRule.ts\");\nconst Specificity_1 = __webpack_require__(/*! ../css/Specificity */ \"./browser/src/css/Specificity.ts\");\nclass StyleNode {\n    constructor(node, specifiedValues, children) {\n        this.node = node;\n        this.specifiedValues = specifiedValues;\n        this.children = children;\n    }\n    lookup(name, name2, fallback) {\n        return this.specifiedValues[name] || this.specifiedValues[name2] || fallback;\n    }\n    value(name) {\n        return this.specifiedValues[name];\n    }\n}\nexports.StyleNode = StyleNode;\nfunction createStyleTree(html, css) {\n    const node = html_1.parseHTML(html);\n    const stylesheet = css_1.parseCSS(css);\n    if (node instanceof Node_1.TextNode) {\n        return new StyleNode(node, {}, []);\n    }\n    return doCreateStyleTree(node, stylesheet);\n}\nexports.createStyleTree = createStyleTree;\n// 类型推导问题 'doCreateStyleTree' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.ts(7023)\nfunction doCreateStyleTree(node, stylesheet) {\n    if (node instanceof Node_1.TextNode) {\n        return new StyleNode(node, {}, []);\n    }\n    if (node instanceof Node_1.ElementNode) {\n        return new StyleNode(node, specifiedValuesForNode(node, stylesheet), node.children.map((child) => doCreateStyleTree(child, stylesheet)));\n    }\n    throw new Error(`unexpected node type ${node}`);\n}\nexports.doCreateStyleTree = doCreateStyleTree;\nfunction specifiedValuesForNode(node, stylesheet) {\n    const matchedRules = matchRulesForNode(node, stylesheet);\n    const specifiedValues = {};\n    for (const rule of matchedRules) {\n        rule.rule.declarations.forEach((value) => {\n            specifiedValues[value.name] = value.value;\n        });\n    }\n    return specifiedValues;\n}\nfunction matchRulesForNode(node, stylesheet) {\n    const matchedRules = [];\n    for (const rule of stylesheet.rules) {\n        const specificity = nodeMatchedWithRule(node, rule);\n        if (specificity) {\n            matchedRules.push(new MatchedRule_1.MatchedRule(specificity, rule));\n        }\n    }\n    matchedRules.sort((a, b) => a.specificity.compare(b.specificity));\n    return matchedRules;\n}\nfunction nodeMatchedWithRule(node, rule) {\n    let specificity = null;\n    for (const selector of rule.selectors) {\n        if (selectorMatchedWithRule(node, selector)) {\n            if (!specificity) {\n                specificity = Specificity_1.Specificity.from(selector);\n            }\n            else {\n                const newSpecificity = Specificity_1.Specificity.from(selector);\n                if (specificity.compare(newSpecificity) < 0) {\n                    specificity = newSpecificity;\n                }\n            }\n        }\n    }\n    return specificity;\n}\nfunction selectorMatchedWithRule(node, selector) {\n    if (selector.tagName && selector.tagName !== node.name) {\n        return false;\n    }\n    if (selector.id && selector.id !== node.attributes['id']) {\n        return false;\n    }\n    const classAttributeValue = node.attributes['class'];\n    const classes = classAttributeValue === undefined ? [] : classAttributeValue.split(' ');\n    if (selector.classes.length > 0 &&\n        !classes.some((klass) => selector.classes.includes(klass))) {\n        return false;\n    }\n    return true;\n}\n\n\n//# sourceURL=webpack://compiler-course/./browser/src/style/index.ts?");

/***/ }),

/***/ "./browser/test/layout/paintingExample.ts":
/*!************************************************!*\
  !*** ./browser/test/layout/paintingExample.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst layout_1 = __webpack_require__(/*! ../../src/layout */ \"./browser/src/layout/index.ts\");\nconst style_1 = __webpack_require__(/*! ../../src/style */ \"./browser/src/style/index.ts\");\nconst painting_1 = __webpack_require__(/*! ../../src/painting */ \"./browser/src/painting/index.ts\");\nconst Rect_1 = __webpack_require__(/*! ../../src/layout/Rect */ \"./browser/src/layout/Rect.ts\");\nconst Dimensions_1 = __webpack_require__(/*! ../../src/layout/Dimensions */ \"./browser/src/layout/Dimensions.ts\");\nconst html = `\n<div class=\"a\">\n</div>\n`;\n// <div class=\"b\">\n//   <div class=\"c\">\n//     <div class=\"d\">\n//       <div class=\"e\">\n//         <div class=\"f\">\n//           <div class=\"g\">\n//           </div>\n//         </div>\n//       </div>\n//     </div>\n//   </div>\n// </div>\nconst css = `\ndiv, html { display: block; padding: 50px; }\n.a { background: #ff0000; }\n`;\n// .b { background: #ffa500; }\n// .c { background: #ffff00; }\n// .d { background: #008000; }\n// .e { background: #0000ff; }\n// .f { background: #4b0082; }\n// .g { background: #800080; }\nconst layoutTree = layout_1.buildLayoutTree(style_1.createStyleTree(html, css));\nconst initialContainingBlock = Dimensions_1.Dimensions.default();\ninitialContainingBlock.content = new Rect_1.Rect(0, 0, 400, 0);\nlayoutTree.layout(initialContainingBlock);\nconst displayList = painting_1.buildDisplayList(layoutTree);\nconst canvasData = painting_1.drawLayoutBoxAsCanvasData(layoutTree, new Rect_1.Rect(0, 0, 400, 400));\nconsole.log('displayList: ', displayList);\nconsole.log('canvasData: ', canvasData);\nconst canvas = document.getElementById('canvas');\nif (canvas) {\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n        const imageData = new ImageData(canvasData.data, canvasData.width, canvasData.height);\n        ctx.putImageData(imageData, 0, 0, 50, 50, 300, 100);\n    }\n}\n\n\n//# sourceURL=webpack://compiler-course/./browser/test/layout/paintingExample.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./browser/test/layout/paintingExample.ts");
/******/ 	
/******/ })()
;